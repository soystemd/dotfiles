#!/bin/sh
# this script opens files based on their extention and mimetype.
# use -h or --help for details.
# requires: file, getopt, awk, sed, grep, cut, nohup.

# paths
programs_file="${XDG_CONFIG_HOME:-$HOME/config}/opener/programs"
types_file="${XDG_CONFIG_HOME:-$HOME/config}/opener/types"

# gnu getopt settings.
name='opener'
short_opts='hftsl:'
long_opts='help,fork,type,same-type,lf:'

# initialize some variables.
check_same_type=false
lf_mode=false
fork=false
fn=open

main()
{
    # process options and arguments.
    opts="$(get_opts "$@")"
    [ $? -ne 0 ] && print_error_exit "bad option(s). use -h or --help."
    eval set -- "$opts"

    # parse options.
    while true; do
        case "$1" in
            -f | --fork ) fork=true; shift ;;
            -t | --type ) fn=findtype; shift ;;
            -s | --same-type ) check_same_type=true; shift ;;
            -l | --lf ) lf_mode=true; lf_id="$2"; shift 2 ;;
            -h | --help) print_help_exit ;;
            --) shift; break ;;
            *) print_error_exit "bad option(s). see -h or --help."
        esac
    done

    # exit if no files given.
    [ -z "$*" ] && print_error_exit "no file(s) given. see -h or --help."

    # check accessiblity of each file.
    exit_if_files_not_readable "$@"

    # check if all file types are the same if user wanted it.
    [ "$check_same_type" = true ] && [ "$#" -gt 1  ] &&
        exit_if_filetypes_different "$@"

    . "$programs_file" # source the "programs" config file
    $fn "$@" # run the intended function.
}


findtype()
{
    file="$1"
    mime="$(getmime "$file")"
    ext="$(getextention "$file")"

    cut -d# -f1 "$types_file" | sed -e '1!b;s/^/\n\n/' |
        awk -v mime="$mime" -v ext="$ext" '
            BEGIN {
                RS="\n{2,}[ \t]*"
                FS="\n[ \t]*"
            } FNR > 1 {
                if ( \
                    (length(mime) > 0 && match(mime,$2)) || \
                    (length(ext)  > 0 && match(ext, $3))    \
                ) {
                    print $1
                    exit
                }
            }
        '
}


gui() {
    [ -z "$DISPLAY" ] &&
        print_error_exit "not in a graphical environment. exiting."

    if [ "$fork" = true ]; then
        setsid -f -- "$@" >/dev/null 2>&1
    else
        nohup -- "$@" >/dev/null 2>&1
    fi
}


fgd() {

    if [ $lf_mode = false ]; then
        exec "$@"
        return
    fi

    cache="${XDG_RUNTIME_DIR:-/tmp}/opener"
    argfile="$cache/args-$$"

    mkdir -p "$cache"
    rm -f "$argfile"

    for arg; do
        echo "$arg" >> "$argfile"
    done

    lf -remote "send $lf_id \$lfargs \"$argfile\""
}


tui() {
    gui "$TERMINAL" -e "$@"
}


getmime()
{
    file --dereference --mime-type --brief -- "$1"
}


getextention()
{
    echo "$1" | awk -F. '{print tolower($NF)}'
}


exit_if_files_not_readable()
{
    for file; do
        [ ! -r "$file" ] && print_error_exit "cannot open file: $file"
    done
}


exit_if_filetypes_different()
{
    are_all_files_same_type "$@" ||
        print_error_exit "$name error: files are not the same type. exiting."
}


are_all_files_same_type()
{
    prev="$(findtype "$1")"
    for file in "$@"; do
        current="$(findtype "$file")"
        [ "$current" != "$prev" ] && return 1
        prev="$current"
    done
}


# format passed options and arguments via gnu getopt.
get_opts()
{
    getopt -qssh -n "$name" -o "$short_opts" -l "$long_opts" -- "$@"
}


print_error_exit()
{
    print_error "opener: $*"
    exit 1
}


print_error()
{
    echo "$@" >&2
}


print_help_exit()
{
cat << 'eof'
opener is a mime-type and extention based file opener script.

usage:
  opener [OPTION...] [--] FILE...

options:
  -f, --fork            run in background. (if it isn't a terminal program.)
  -t, --type            print given files' type and exit.
  -s, --same-type       only open files if all of them are the same type.
  -l, --lf <id>         lf mode; like regular mode, but with some extra
                          bells and whistles for lf file manager.
                          id of the lf instance must be provided.
  -h, --help            show this help message.

lf mode:
  in this mode, foreground programs are sent directly to lf
  to run, and gui programs are forked like regular mode.

  this means that from lf, you can run opener in background
  and still be able to run foreground programs.

  put something like this in your lfrc:
    cmd open &opener --lf $id -- $f

  in this mode, variable $lf_mode is set to true (it's false
  in regular mode), and variable $lf_id is the lf's id.
eof
exit
}


main "$@"
exit
